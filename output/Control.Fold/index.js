// Generated by purs version 0.11.7
"use strict";
var Control_Alt = require("../Control.Alt");
var Control_Applicative = require("../Control.Applicative");
var Control_Apply = require("../Control.Apply");
var Control_Category = require("../Control.Category");
var Control_Comonad = require("../Control.Comonad");
var Control_Extend = require("../Control.Extend");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Data_Bounded = require("../Data.Bounded");
var Data_Distributive = require("../Data.Distributive");
var Data_Eq = require("../Data.Eq");
var Data_Foldable = require("../Data.Foldable");
var Data_Function = require("../Data.Function");
var Data_Functor = require("../Data.Functor");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra");
var Data_Maybe = require("../Data.Maybe");
var Data_Monoid = require("../Data.Monoid");
var Data_Ord = require("../Data.Ord");
var Data_Profunctor = require("../Data.Profunctor");
var Data_Profunctor_Closed = require("../Data.Profunctor.Closed");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Semiring = require("../Data.Semiring");
var Data_Traversable = require("../Data.Traversable");
var Data_Unit = require("../Data.Unit");
var Prelude = require("../Prelude");
var Fold = function (x) {
    return x;
};
var unfoldFold = function (s0) {
    return function (step) {
        return function (finish) {
            var go = function (s) {
                return {
                    step: function ($50) {
                        return go(step(s)($50));
                    },
                    finish: function (v) {
                        return finish(s);
                    }
                };
            };
            return go(s0);
        };
    };
};
var unfoldFold_ = function (s0) {
    return function (step) {
        return unfoldFold(s0)(step)(Control_Category.id(Control_Category.categoryFn));
    };
};
var sum = function (dictSemiring) {
    return unfoldFold_(Data_Semiring.zero(dictSemiring))(Data_Semiring.add(dictSemiring));
};
var stepFold = function (a) {
    return function (v) {
        return v.step(a);
    };
};
var profunctorFold = new Data_Profunctor.Profunctor(function (f) {
    return function (g) {
        return function (v) {
            var step = function ($51) {
                return Data_Profunctor.dimap(profunctorFold)(f)(g)(v.step(f($51)));
            };
            var finish = function ($52) {
                return g(v.finish($52));
            };
            return {
                step: step,
                finish: finish
            };
        };
    };
});
var product = function (dictSemiring) {
    return unfoldFold_(Data_Semiring.one(dictSemiring))(Data_Semiring.mul(dictSemiring));
};
var or = function (dictHeytingAlgebra) {
    return unfoldFold_(Data_HeytingAlgebra.ff(dictHeytingAlgebra))(Data_HeytingAlgebra.disj(dictHeytingAlgebra));
};
var $$null = unfoldFold_(true)(function (v) {
    return function (v1) {
        return false;
    };
});
var minimum = function (dictBounded) {
    return unfoldFold_(Data_Bounded.top(dictBounded))(Data_Ord.min(dictBounded.Ord0()));
};
var mconcat = function (dictMonoid) {
    return unfoldFold_(Data_Monoid.mempty(dictMonoid))(Data_Semigroup.append(dictMonoid.Semigroup0()));
};
var maximum = function (dictBounded) {
    return unfoldFold_(Data_Bounded.bottom(dictBounded))(Data_Ord.max(dictBounded.Ord0()));
};
var length = function (dictSemiring) {
    return unfoldFold_(Data_Semiring.zero(dictSemiring))(function (n) {
        return function (v) {
            return Data_Semiring.add(dictSemiring)(n)(Data_Semiring.one(dictSemiring));
        };
    });
};
var last = unfoldFold_(Data_Maybe.Nothing.value)(function (v) {
    return function (a) {
        return new Data_Maybe.Just(a);
    };
});
var head = unfoldFold_(Data_Maybe.Nothing.value)(function (m) {
    return function (a) {
        return Control_Alt.alt(Data_Maybe.altMaybe)(m)(new Data_Maybe.Just(a));
    };
});
var functorFold = new Data_Functor.Functor(function (f) {
    return function (v) {
        var step = function ($53) {
            return Data_Functor.map(functorFold)(f)(v.step($53));
        };
        var finish = function ($54) {
            return f(v.finish($54));
        };
        return {
            step: step,
            finish: finish
        };
    };
});
var extendFold = new Control_Extend.Extend(function () {
    return functorFold;
}, function (f) {
    var dup = function (v) {
        var step = function (a) {
            return dup(v.step(a));
        };
        var finish = function (v1) {
            return v;
        };
        return {
            step: step,
            finish: finish
        };
    };
    return function ($55) {
        return Data_Functor.map(functorFold)(f)(dup($55));
    };
});
var comonadFold = new Control_Comonad.Comonad(function () {
    return extendFold;
}, function (v) {
    return v.finish(Data_Unit.unit);
});
var foldl = function (dictFoldable) {
    return function (fold) {
        return function (xs) {
            return Control_Comonad.extract(comonadFold)(Data_Foldable.foldl(dictFoldable)(function (v) {
                return v.step;
            })(fold)(xs));
        };
    };
};
var scanl = function (dictTraversable) {
    return function (fold) {
        return function (xs) {
            return Data_Functor.map(dictTraversable.Functor0())(Control_Comonad.extract(comonadFold))(Data_Traversable.scanl(dictTraversable)(function (v) {
                return v.step;
            })(fold)(xs));
        };
    };
};
var closedFold = new Data_Profunctor_Closed.Closed(function () {
    return profunctorFold;
}, function (f) {
    return unfoldFold(Data_Function["const"](f))(Control_Apply.lift2(Control_Apply.applyFn)(Data_Function.flip(stepFold)))(function (v) {
        return function ($56) {
            return Control_Comonad.extract(comonadFold)(v($56));
        };
    });
});
var distributed = function (dictDistributive) {
    return function ($57) {
        return Data_Profunctor.dimap(profunctorFold)(Data_Function.applyFlipped)(Data_Function.flip(Data_Distributive.cotraverse(dictDistributive)(Data_Functor.functorFn))(Control_Category.id(Control_Category.categoryFn)))(Data_Profunctor_Closed.closed(closedFold)($57));
    };
};
var applyFold = new Control_Apply.Apply(function () {
    return functorFold;
}, function (v) {
    return function (v1) {
        var step = function (a) {
            return Control_Apply.apply(applyFold)(v.step(a))(v1.step(a));
        };
        var finish = function (u) {
            return v.finish(u)(v1.finish(u));
        };
        return {
            step: step,
            finish: finish
        };
    };
});
var semigroupFold = function (dictSemigroup) {
    return new Data_Semigroup.Semigroup(Control_Apply.lift2(applyFold)(Data_Semigroup.append(dictSemigroup)));
};
var applicativeFold = new Control_Applicative.Applicative(function () {
    return applyFold;
}, function (b) {
    var done = {
        step: function (v) {
            return done;
        },
        finish: function (v) {
            return b;
        }
    };
    return done;
});
var monoidFold = function (dictMonoid) {
    return new Data_Monoid.Monoid(function () {
        return semigroupFold(dictMonoid.Semigroup0());
    }, Control_Applicative.pure(applicativeFold)(Data_Monoid.mempty(dictMonoid)));
};
var any = function (dictHeytingAlgebra) {
    return function (pred) {
        return Data_Profunctor.lmap(profunctorFold)(pred)(or(dictHeytingAlgebra));
    };
};
var elem = function (dictEq) {
    return function (a) {
        return any(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (v) {
            return Data_Eq.eq(dictEq)(v)(a);
        });
    };
};
var and = function (dictHeytingAlgebra) {
    return unfoldFold_(Data_HeytingAlgebra.tt(dictHeytingAlgebra))(Data_HeytingAlgebra.conj(dictHeytingAlgebra));
};
var all = function (dictHeytingAlgebra) {
    return function (pred) {
        return Data_Profunctor.lmap(profunctorFold)(pred)(and(dictHeytingAlgebra));
    };
};
var notElem = function (dictEq) {
    return function (a) {
        return all(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (v) {
            return Data_Eq.notEq(dictEq)(v)(a);
        });
    };
};
module.exports = {
    stepFold: stepFold,
    unfoldFold: unfoldFold,
    unfoldFold_: unfoldFold_,
    foldl: foldl,
    scanl: scanl,
    mconcat: mconcat,
    head: head,
    last: last,
    "null": $$null,
    length: length,
    and: and,
    or: or,
    any: any,
    all: all,
    sum: sum,
    product: product,
    maximum: maximum,
    minimum: minimum,
    elem: elem,
    notElem: notElem,
    distributed: distributed,
    profunctorFold: profunctorFold,
    closedFold: closedFold,
    functorFold: functorFold,
    applyFold: applyFold,
    applicativeFold: applicativeFold,
    extendFold: extendFold,
    comonadFold: comonadFold,
    semigroupFold: semigroupFold,
    monoidFold: monoidFold
};
